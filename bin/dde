#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dde_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde - Docker Desktop Environment\n"
    echo

  else
    printf "dde - Docker Desktop Environment\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dde [command]\n"
  printf "  dde [command] --help | -h\n"
  printf "  dde --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  init      Initializes dde. Only has to be run once from directory docker-dev-environment is installed"
  echo "  list      Lists all available services"
  echo "  start     Starts or restarts (if running) one container if provided "
  echo "  build     Builds or rebuilds given container, or all if --a option is given"
  echo "  bash      Starts bash in default cli container or alternative container if given"
  echo "  command   Executes a specific command on a given container"
  echo "  test      Test command for development"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dde_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  else
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  fi

  printf "Shortcut: i\n"
  echo

  printf "Usage:\n"
  printf "  dde init\n"
  printf "  dde init --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde list - Lists all available services\n"
    echo

  else
    printf "dde list - Lists all available services\n"
    echo

  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  dde list\n"
  printf "  dde list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde start\n"
    echo

    printf "  Starts or restarts (if running) one container if provided \n   or all the containers needed for an application \n   as defined in local .env file. \n   See .env.project.sample for documentation\n"
    echo

  else
    printf "dde start - Starts or restarts (if running) one container if provided \n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  dde start [CONTAINER]\n"
  printf "  dde start --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container\n"
    echo

  fi
}

# :command.usage
dde_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde build - Builds or rebuilds given container, or all if --a option is given\n"
    echo

  else
    printf "dde build - Builds or rebuilds given container, or all if --a option is given\n"
    echo

  fi

  printf "Shortcut: x\n"
  echo

  printf "Usage:\n"
  printf "  dde build [CONTAINER] [options]\n"
  printf "  dde build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Builds all containers\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container\n"
    echo

  fi
}

# :command.usage
dde_bash_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  else
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  fi

  printf "Shortcut: b\n"
  echo

  printf "Usage:\n"
  printf "  dde bash [CONTAINER] [options]\n"
  printf "  dde bash --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    echo "  --root, -s"
    printf "    Starts command as root user\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  dde bash\n"
    printf "  dde bash -r -s mysql-80\n"
    echo

  fi
}

# :command.usage
dde_command_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde command - Executes a specific command on a given container\n"
    echo

  else
    printf "dde command - Executes a specific command on a given container\n"
    echo

  fi

  printf "Shortcut: c\n"
  echo

  printf "Usage:\n"
  printf "  dde command CONTAINER COMMAND [options]\n"
  printf "  dde command --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    echo "  --root, -s"
    printf "    Starts command as root user\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    name of the container\n"
    echo

    # :argument.usage
    echo "  COMMAND"
    printf "\n"
    echo

  fi
}

# :command.usage
dde_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde test - Test command for development\n"
    echo

  else
    printf "dde test - Test command for development\n"
    echo

  fi

  printf "Shortcut: t\n"
  echo

  printf "Usage:\n"
  printf "  dde test\n"
  printf "  dde test --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/build.sh
touchConfigFile () {

  if [[ $1 =~ "php" ]]; then
    part="${1/-x//}"
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/etc/php/php.ini"
  fi

  if [[ $1 =~ mysql|percona|mariadb ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/my.cnf"
  fi

  if [[ $1 =~ "ssh" ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/tunnel.conf"
  fi

  if [[ -n "${configFile}" && ! -f "${configFile}" ]]; then
    echo "Touching ${configFile} before startup, because it does not exist"
    touch "${configFile}"
    if [[ $part =~ "php" ]]; then
      echo 'Copying ini files, adopt to your needs'
      cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/sample/conf.d/*.ini" \
         "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/etc/php/conf.d"
    fi
  fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/init.sh
init_rc() {

  cat >> "${BASHRC_FILE}" <<EOL_SH
  #
  # initialising docker dev environment
  #
  source ~/.docker/.dderc
EOL_SH
}

init_path() {
    cat > ~/.docker/.dderc <<EOL_DOCKER
    #
    # initialising docker dev environment
    #
    export DOCKER_DEV_ENVIRONMENT_HOME="${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}"
    if [[ -d "\${DOCKER_DEV_ENVIRONMENT_HOME}/bin" ]]; then
        PATH="\${DOCKER_DEV_ENVIRONMENT_HOME}/bin:\${PATH}"
    fi
EOL_DOCKER
}

# :command.command_functions
# :command.function
dde_init_command() {
  # src/init_command.sh
  REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME=$(readlink -f "${MY_PATH}/..")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  # if it is no set or changed
  #
  if [[ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then

      BASHRC_FILE="${HOME}/.bashrc"
      #
      # check if source command is included in .bashrc if the file exists
      #
      if [[ -f $BASHRC_FILE  && "$(grep -c ".docker/.dderc" ${BASHRC_FILE})" = "0" ]]; then
          init_rc
      fi

      ZSHRC_FILE="${HOME}/.zshrc"
      #
      # check if source command is included in .zshrc if the file exists
      #
      if [[ -f $ZSHRC_FILE  && "$(grep -c ".docker/.dderc" ${ZSHRC_FILE})" = "0" ]]; then
          init_rc
      fi

      #
      # check if .devenvrc file exists
      #
      if [[ ! -d ~/.docker ]]; then
         mkdir ~/.docker
      fi

      if [[ ( ! -f ~/.docker/.dderc ) || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then
          init_path
      fi

      green "docker dev environment initialized or changed, please type"
      if [[ "$(grep -c "/bash" ${SHELL})" != "0" ]]; then
          green "$ source $BASHRC_FILE "
      elif [[ "$(grep -c "/zsh" ${SHELL})" != "0" ]]; then
          green "$ source $ZSHRC_FILE "
      else
          green "$ source /pfad/zur/config/datei/der/shell "
      fi
      green "to see effects"
  else
      magenta "docker dev environment already initialised"
  fi
}

# :command.function
dde_list_command() {
  # src/list_command.sh
  green "Listing all defined services"
  echo
  docker-compose  -f ${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml config --service
  echo
  green "Done"
}

# :command.function
dde_start_command() {
  # src/start_command.sh
  echo "# this file is located in 'src/start_command.sh'"
  echo "# code for 'dde start' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dde_build_command() {
  # src/build_command.sh
  echo "# this file is located in 'src/build_command.sh'"
  echo "# code for 'dde build' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dde_bash_command() {
  # src/bash_command.sh
  echo "# this file is located in 'src/bash_command.sh'"
  echo "# code for 'dde bash' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dde_command_command() {
  # src/command_command.sh
  echo "# this file is located in 'src/command_command.sh'"
  echo "# code for 'dde command' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
dde_test_command() {
  # src/test_command.sh
  green done
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dde_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  init | i )
    action="init"
    shift
    dde_init_parse_requirements "$@"
    shift $#
    ;;

  list | l )
    action="list"
    shift
    dde_list_parse_requirements "$@"
    shift $#
    ;;

  start | s )
    action="start"
    shift
    dde_start_parse_requirements "$@"
    shift $#
    ;;

  build | x )
    action="build"
    shift
    dde_build_parse_requirements "$@"
    shift $#
    ;;

  bash | b )
    action="bash"
    shift
    dde_bash_parse_requirements "$@"
    shift $#
    ;;

  command | c )
    action="command"
    shift
    dde_command_parse_requirements "$@"
    shift $#
    ;;

  test | t )
    action="test"
    shift
    dde_test_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    dde_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_init_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="init"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_list_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_start_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_start_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="start"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_build_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_build_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="build"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )
      # :flag.conflicts
      args[--all]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_bash_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_bash_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="bash"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --run | -r )
      # :flag.conflicts
      args[--run]=1
      shift
      ;;

    # :flag.case
    --root | -s )
      # :flag.conflicts
      args[--root]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_command_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_command_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="command"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --run | -r )
      # :flag.conflicts
      args[--run]=1
      shift
      ;;

    # :flag.case
    --root | -s )
      # :flag.conflicts
      args[--root]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      elif [[ -z ${args[command]+x} ]]; then
        # :argument.validations
        args[command]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[container]+x} ]]; then
    printf "missing required argument: CONTAINER\nusage: dde command CONTAINER COMMAND [options]\n"
    exit 1
  fi
  if [[ -z ${args[command]+x} ]]; then
    printf "missing required argument: COMMAND\nusage: dde command CONTAINER COMMAND [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_test_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_test_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="test"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

  SCRIPT_PATH=$(readlink -f "$0")
  MY_PATH=$(dirname "$SCRIPT_PATH")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  #
  if [ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" ]; then
      magenta "Warning: dde not initialised, use dde init to do so"
  fi

  if [ -f "${MY_PATH}/../.env" ]; then
   set -a
   . "${MY_PATH}/../.env"
   set +a
  else
    echo "Please copy the file .env.sample file inside your docker-dev-environment to .env and change according to your needs"
    exit 1
  fi

  if [ -f "${PWD}/.env" ]; then
    set -a
    . "${PWD}/.env"
    set +a
  elif [ "${DOCKER_DEV_ENVIRONMENT_HOME}" != "${PWD}" ]; then
    ENV_WARNING="Warning: there is no .env in your current working dir. Wrong pwd or missing project initialisation?"
  fi
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_init_usage
    else
      dde_init_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_list_usage
    else
      dde_list_command
    fi

  elif [[ $action == "start" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_start_usage
    else
      dde_start_command
    fi

  elif [[ $action == "build" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_build_usage
    else
      dde_build_command
    fi

  elif [[ $action == "bash" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_bash_usage
    else
      dde_bash_command
    fi

  elif [[ $action == "command" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_command_usage
    else
      dde_command_command
    fi

  elif [[ $action == "test" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_test_usage
    else
      dde_test_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
