#!/usr/bin/env bash
# This script was generated by bashly 0.7.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dde_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde - Docker Desktop Environment\n"
    echo

  else
    printf "dde - Docker Desktop Environment\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dde [command]\n"
  printf "  dde [command] --help | -h\n"
  printf "  dde --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  init      Initializes dde. Only has to be run once from directory docker-dev-environment is installed"
  echo "  list      Lists all available services"
  echo "  start     Starts or restarts (if flag -r is given) one or several "
  echo "  restart   Shortcut for dde start -r"
  echo "  build     Builds or rebuilds one or multiple containers. "
  echo "  bash      Starts bash in default cli container or alternative container if given"
  echo "  command   Executes a specific command on the default (or given via --service) service"
  echo "  test      Test command for development"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dde_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  else
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  fi

  printf "Shortcut: i\n"
  echo

  printf "Usage:\n"
  printf "  dde init\n"
  printf "  dde init --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde list - Lists all available services\n"
    echo

  else
    printf "dde list - Lists all available services\n"
    echo

  fi

  printf "Shortcut: l\n"
  echo

  printf "Usage:\n"
  printf "  dde list\n"
  printf "  dde list --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde start\n"
    echo

    printf "  Starts or restarts (if flag -r is given) one or several \n   containers if provided. Use colon seperated list for multiple containers. \n   If no containers are given all the containers needed for \n   an application are started as defined in the local .env file. \n   See .env.project.sample for documentation\n"
    echo

  else
    printf "dde start - Starts or restarts (if flag -r is given) one or several \n"
    echo

  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  dde start [CONTAINER] [options]\n"
  printf "  dde start --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --restart, -r"
    printf "    forces restart if container is running\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container(s)\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  \"dde start\": starts all the containers defined in the variable\n  DOCKER_CONTAINER\n"
    printf "  \"dde start -r\": as above, but containers are stopped first if running\n"
    printf "  \"dde start -r apache-24,php-fpm-81\": restarts the two given containers\n"
    echo

  fi
}

# :command.usage
dde_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde restart - Shortcut for dde start -r\n"
    echo

  else
    printf "dde restart - Shortcut for dde start -r\n"
    echo

  fi

  printf "Shortcut: r\n"
  echo

  printf "Usage:\n"
  printf "  dde restart [CONTAINER]\n"
  printf "  dde restart --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container(s), see dde start -h for more help\n"
    echo

  fi
}

# :command.usage
dde_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde build\n"
    echo

    printf "  Builds or rebuilds one or multiple containers. \n   If multiple container building is desired use colon seperated list.\n   If container list is omitted, all containers needed for your\n   application (as defined in your local .env file) will be built or \n   rebuilt.\n   If the --all option is given, all dde containers are built. \n   BEWARE: this might take some time. \n   If the --restart option is given, the service will be restarted after\n   being built. BEWARE: you can not combine the two options,\n   as there are too many containers to be run at\n   the same time.\n  \n   The command uses the --force-rm --no-cache --pull options from\n   docker-compose build and therefor takes some time. \n   For more fine grained tuning use\n  \n   docker-compose build -f ${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml\n  build\n  \n   with the options that suite you best.\n"
    echo

  else
    printf "dde build - Builds or rebuilds one or multiple containers. \n"
    echo

  fi

  printf "Shortcut: x\n"
  echo

  printf "Usage:\n"
  printf "  dde build [CONTAINER] [options]\n"
  printf "  dde build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --all, -a"
    printf "    Build all containers defined in the dde docker-compose.yml\n"
    echo

    # :flag.usage
    echo "  --restart, -r"
    printf "    restarts (or starts) the (re)built container\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  CONTAINER"
    printf "    Name of container(s)\n"
    echo

  fi
}

# :command.usage
dde_bash_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  else
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  fi

  printf "Shortcut: b\n"
  echo

  printf "Usage:\n"
  printf "  dde bash [options]\n"
  printf "  dde bash --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    echo "  --root, -o"
    printf "    Starts command as root user\n"
    echo

    # :flag.usage
    echo "  --default-working-dir, -d"
    printf "    Uses default working dir rather than project root\n"
    echo

    # :flag.usage
    echo "  --service, -s SERVICE"
    printf "    The service to execute the command in, defaults to the one \n     defined in $DEFAULT_CONTAINER\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  dde bash: Starts ab bash on the running default service\n"
    printf "  dde bash -r -o -s mysql-80: Starts a bash in a newly created mysql-80 service\n  as root\n"
    echo

  fi
}

# :command.usage
dde_command_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde command - Executes a specific command on the default (or given via --service) service\n"
    echo

  else
    printf "dde command - Executes a specific command on the default (or given via --service) service\n"
    echo

  fi

  printf "Shortcut: c\n"
  echo

  printf "Usage:\n"
  printf "  dde command COMMAND [options]\n"
  printf "  dde command --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    echo "  --root, -o"
    printf "    Starts command as root user\n"
    echo

    # :flag.usage
    echo "  --default-working-dir, -d"
    printf "    Uses default working dir rather than project root\n"
    echo

    # :flag.usage
    echo "  --service, -s SERVICE"
    printf "    The service to execute the command in, defaults to the one \n     defined in $DEFAULT_CONTAINER\n"
    echo

    # :flag.usage
    echo "  --no-tty, -T"
    printf "    Do not allocate tty while executing command. This is needed for execution of\n    cronjobs.\n     See the documentation for more details\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  COMMAND"
    printf "    The command to execute, needs to be quoted if it contains spaces\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"

    printf "  dde command \"ls -l\": lists the dir content on the running default service\n"
    printf "  dde c -T -s redis-5 redis-cli flushall: flushes the redis cache from a cron\n  job (i.e. without tty)\n"
    echo

  fi
}

# :command.usage
dde_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde test - Test command for development\n"
    echo

  else
    printf "dde test - Test command for development\n"
    echo

  fi

  printf "Shortcut: t\n"
  echo

  printf "Usage:\n"
  printf "  dde test COMMAND [options]\n"
  printf "  dde test --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --service, -s SERVICE"
    printf "    The service to execute the\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  COMMAND"
    printf "    The command to execute\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/build.sh
touchConfigFile () {

  if [[ $1 =~ "php" ]]; then
    part="${1/-x//}"
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/etc/php/php.ini"
  fi

  if [[ $1 =~ mysql|percona|mariadb ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/my.cnf"
  fi

  if [[ $1 =~ "ssh" ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/tunnel.conf"
  fi

  if [[ -n "${configFile}" && ! -f "${configFile}" ]]; then
    echo "Touching ${configFile} before startup, because it does not exist"
    touch "${configFile}"
    if [[ $part =~ "php" ]]; then
      echo 'Copying ini files, adopt to your needs'
      cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/sample/conf.d/*.ini" \
         "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/etc/php/conf.d"
    fi
  fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/init.sh
init_rc() {

  cat >> "${BASHRC_FILE}" <<EOL_SH
#
# initialising docker dev environment
#
source ~/.docker/.dderc
EOL_SH
}

init_path() {
    cat > ~/.docker/.dderc <<EOL_PATH
#
# initialising docker dev environment
#
export DOCKER_DEV_ENVIRONMENT_HOME="${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}"
if [[ -d "\${DOCKER_DEV_ENVIRONMENT_HOME}/bin" ]]; then
    PATH="\${DOCKER_DEV_ENVIRONMENT_HOME}/bin:\${PATH}"
fi
EOL_PATH
}

# :command.command_functions
# :command.function
dde_init_command() {
  # src/init_command.sh
  REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME=$(readlink -f "${MY_PATH}/..")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  # if it is no set or changed
  #
  if [[ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then

      BASHRC_FILE="${HOME}/.bashrc"
      #
      # check if source command is included in .bashrc if the file exists
      #
      if [[ -f $BASHRC_FILE  && "$(grep -c ".docker/.dderc" "${BASHRC_FILE}")" = "0" ]]; then
          init_rc
      fi

      ZSHRC_FILE="${HOME}/.zshrc"
      #
      # check if source command is included in .zshrc if the file exists
      #
      if [[ -f $ZSHRC_FILE  && "$(grep -c ".docker/.dderc" "${ZSHRC_FILE}")" = "0" ]]; then
          init_rc
      fi

      #
      # check if .devenvrc file exists
      #
      if [[ ! -d ~/.docker ]]; then
         mkdir ~/.docker
      fi

      if [[ ( ! -f ~/.docker/.dderc ) || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then
          init_path
      fi

      green "docker dev environment initialized or changed, please type"
      if [[ "$(grep -c "/bash" "${SHELL}")" != "0" ]]; then
          green "$ source $BASHRC_FILE "
      elif [[ "$(grep -c "/zsh" "${SHELL}")" != "0" ]]; then
          green "$ source $ZSHRC_FILE "
      else
          green "$ source /pfad/zur/config/datei/der/shell "
      fi
      green "to see effects"
  else
      magenta "docker dev environment already initialised"
  fi
}

# :command.function
dde_list_command() {
  # src/list_command.sh
  green "Listing all defined services:"
  docker-compose  -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" config --service
}

# :command.function
dde_start_command() {
  # src/start_command.sh
  parse_command_args
  if [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
         while IFS=',' read -ra CONTAINER; do
            for container in "${CONTAINER[@]}"; do
                if [ -v "args[--restart]" ]; then
                    docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" stop ${container}
                fi
                touchConfigFile "${container}"
                docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" up -d ${container}
            done
         done <<< "${CONTAINER_LIST}"
  fi
}

# :command.function
dde_restart_command() {
  # src/restart_command.sh
  parse_command_args
  if [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
      dde start "${CONTAINER_LIST}" -r
  fi
}

# :command.function
dde_build_command() {
  # src/build_command.sh
  parse_command_args
  if [ -v "args[--all]" ]; then
      if [ -v "args[--restart]" ]; then
          red "You can not provide the two options together!"
      else
          docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" build "${BUILD_OPTIONS}"
      fi
  elif [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
         while IFS=',' read -ra CONTAINER; do
            for container in "${CONTAINER[@]}"; do
                docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" build \
                   --force-rm --pull --no-cache "${container}"
                if [ -v "args[--restart]" ]; then
                    dde restart "${container}"
                fi
            done
         done <<< "${CONTAINER_LIST}"
  fi
}

# :command.function
dde_bash_command() {
  # src/bash_command.sh
  #inspect_args
  parse_command_args
  if [ -v SERVICE_WARNING ]; then
      red "${SERVICE_WARNING}"
      red "${ENV_WARNING}"
  else
      docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" "${MODEPART[@]}" \
          "${USERPART[@]}" "${WORKINGDIRPART[@]}" "${SERVICE}" bash
  fi
}

# :command.function
dde_command_command() {
  # src/command_command.sh
  parse_command_args
  if [ -v SERVICE_WARNING ]; then
      red "${SERVICE_WARNING}"
      red "${ENV_WARNING}"
  else
      docker-compose -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" "${MODEPART[@]}" \
          "${TTYPART[@]}" "${USERPART[@]}" "${WORKINGDIRPART[@]}" "${SERVICE}" "${COMMAND[@]}"
  fi
}

# :command.function
dde_test_command() {
  # src/test_command.sh
  inspect_args
  if [ -v "args[--service]" ]; then
      red "${args[--service]}"
  fi
  green "done"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    dde_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  init | i )
    action="init"
    shift
    dde_init_parse_requirements "$@"
    shift $#
    ;;

  list | l )
    action="list"
    shift
    dde_list_parse_requirements "$@"
    shift $#
    ;;

  start | s )
    action="start"
    shift
    dde_start_parse_requirements "$@"
    shift $#
    ;;

  restart | r )
    action="restart"
    shift
    dde_restart_parse_requirements "$@"
    shift $#
    ;;

  build | x )
    action="build"
    shift
    dde_build_parse_requirements "$@"
    shift $#
    ;;

  bash | b )
    action="bash"
    shift
    dde_bash_parse_requirements "$@"
    shift $#
    ;;

  command | c )
    action="command"
    shift
    dde_command_parse_requirements "$@"
    shift $#
    ;;

  test | t )
    action="test"
    shift
    dde_test_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  * )
    dde_usage
    exit 1
    ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_init_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_init_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="init"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_list_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="list"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_start_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_start_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="start"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --restart | -r )
      # :flag.conflicts
      args[--restart]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_restart_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_restart_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="restart"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_build_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_build_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="build"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --all | -a )
      # :flag.conflicts
      args[--all]=1
      shift
      ;;

    # :flag.case
    --restart | -r )
      # :flag.conflicts
      args[--restart]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[container]+x} ]]; then
        # :argument.validations
        args[container]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_bash_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_bash_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="bash"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --run | -r )
      # :flag.conflicts
      args[--run]=1
      shift
      ;;

    # :flag.case
    --root | -o )
      # :flag.conflicts
      args[--root]=1
      shift
      ;;

    # :flag.case
    --default-working-dir | -d )
      # :flag.conflicts
      args[--default-working-dir]=1
      shift
      ;;

    # :flag.case
    --service | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--service]="$2"
        shift
        shift
      else
        printf "%s\n" "--service requires an argument: --service, -s SERVICE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_command_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_command_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="command"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --run | -r )
      # :flag.conflicts
      args[--run]=1
      shift
      ;;

    # :flag.case
    --root | -o )
      # :flag.conflicts
      args[--root]=1
      shift
      ;;

    # :flag.case
    --default-working-dir | -d )
      # :flag.conflicts
      args[--default-working-dir]=1
      shift
      ;;

    # :flag.case
    --service | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--service]="$2"
        shift
        shift
      else
        printf "%s\n" "--service requires an argument: --service, -s SERVICE"
        exit 1
      fi
      ;;

    # :flag.case
    --no-tty | -T )
      # :flag.conflicts
      args[--no-tty]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[command]+x} ]]; then
        # :argument.validations
        args[command]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[command]+x} ]]; then
    printf "missing required argument: COMMAND\nusage: dde command COMMAND [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dde_test_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    dde_test_usage
    exit
    ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="test"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --service | -s )
      # :flag.conflicts
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        args[--service]="$2"
        shift
        shift
      else
        printf "%s\n" "--service requires an argument: --service, -s SERVICE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      if [[ -z ${args[command]+x} ]]; then
        # :argument.validations
        args[command]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;

    esac
  done
  # :command.required_args_filter
  if [[ -z ${args[command]+x} ]]; then
    printf "missing required argument: COMMAND\nusage: dde test COMMAND [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
  # where is this file located
  SCRIPT_PATH=$(readlink -f "$0")
  MY_PATH=$(dirname "$SCRIPT_PATH")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  #
  if [ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" ]; then
      magenta "Warning: dde not initialised, use dde init to do so"
  fi

  # initializes the dde wide variables like user id etc.
  # see .env.sample
  #
  if [ -f "${MY_PATH}/../.env" ]; then
   set -a
   . "${MY_PATH}/../.env"
   set +a
  else
    echo "Please copy the file .env.sample file inside your docker-dev-environment to .env and change according to your needs"
    exit 1
  fi

  # initializes the specific container needs for a given project
  # see .env.project-sample
  if [ -f "${PWD}/.env.dde" ]; then
    set -a
    . "${PWD}/.env.dde"
    set +a
  elif [ -f "${PWD}/.env" ]; then
    set -a
    . "${PWD}/.env"
    set +a
  elif [ "${DOCKER_DEV_ENVIRONMENT_HOME}" != "${PWD}" ]; then
    ENV_WARNING="Warning: there is no .env in your current working dir. Wrong pwd or missing project initialisation?"
  fi

  # creates an empty config file for services which are started
  # for the first time.
  # for php container a sample php.ini is copied
  touchConfigFile () {

    if [[ $1 =~ "php" ]]; then
      part="${1/-x//}"
      configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part/etc/php/php.ini"
    fi

    if [[ $1 =~ mysql|percona|mariadb ]]; then
      configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/my.cnf"
    fi

    if [[ $1 =~ "ssh" ]]; then
      configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/tunnel.conf"
    fi

    if [[ $1 =~ "opensearch" ]]; then
      part="${1/-x//}"
      configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/config/initialized"
    fi

    if [[ -n "${configFile}" && ! -f "${configFile}" ]]; then
      echo "Touching ${configFile} before startup, because it does not exist"
      touch "${configFile}"
      if [[ $part =~ "php" ]]; then
        echo 'Copying ini files, adopt to your needs'
        cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part"/sample/conf.d/*.ini \
           "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part"/etc/php/conf.d
      fi
      if [[ $part =~ "opensearch" ]]; then
          echo 'Copying config files, adopt to your needs'
          cp -R "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part"/sample/* \
                "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$part"/config
      fi
    fi
  }

  # parses the command args
  # see https://github.com/koalaman/shellcheck/wiki/SC2086 for argument parsing in shell
  function parse_command_args() {

      # determine working dir
      if [ -v "args[--default-working-dir]" ]; then
          WORKINGDIRPART=()
      elif [ -v "PROJECT_ROOT" ]; then
          WORKINGDIRPART=(-w /var/www/vhosts/${PROJECT_ROOT})
      else
          WORKINGDIRPART=()
      fi

      # set root user if desired
      if [ -v "args[--root]" ]; then
          USERPART=(-u root)
      else
          USERPART=(-u ${USER_ID})
      fi

      # determine run type

      if [ -v "args[--run]" ]; then
          MODEPART=(run --rm)
      else
          MODEPART=(exec)
      fi

      #
      if [ -v "args[--no-tty]" ]; then
          TTYPART=(-T)
      else
          TTYPART=()
      fi

      # seek default service for command execution
      if [ -v "args[--service]" ]; then
          SERVICE="${args[--service]}"
      # inspect PHP_CLI_CONTAINER for backward compatibility
      elif [ -v "PHP_CLI_CONTAINER" ]; then
          SERVICE="${PHP_CLI_CONTAINER}"
      elif [ -v "DEFAULT_CONTAINER" ]; then
          SERVICE="${DEFAULT_CONTAINER}"
      else
          SERVICE_WARNING="Could not determine the service to execute the command on!"
      fi

      # prepares the container list for dde start and dde build
      if [ -v "args[container]" ]; then
          CONTAINER_LIST="${args[container]}"
      elif [ -v "DOCKER_CONTAINER" ]; then
          CONTAINER_LIST="${DOCKER_CONTAINER}"
          # inspect PHP_FPM_CONTAINER for backward compatibility
          if [ -v "PHP_FPM_CONTAINER" ]; then
              CONTAINER_LIST="${CONTAINER_LIST},${PHP_FPM_CONTAINER}"
          fi
      else
          CONTAINER_WARNING="No container given!"
      fi

      if [ -v "args[command]" ]; then
          IFS=" " read -ra COMMAND<<<"${args[command]}"
      fi
  }
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "init" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_init_usage
    else
      dde_init_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_list_usage
    else
      dde_list_command
    fi

  elif [[ $action == "start" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_start_usage
    else
      dde_start_command
    fi

  elif [[ $action == "restart" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_restart_usage
    else
      dde_restart_command
    fi

  elif [[ $action == "build" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_build_usage
    else
      dde_build_command
    fi

  elif [[ $action == "bash" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_bash_usage
    else
      dde_bash_command
    fi

  elif [[ $action == "command" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_command_usage
    else
      dde_command_command
    fi

  elif [[ $action == "test" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dde_test_usage
    else
      dde_test_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
