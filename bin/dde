#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dde_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde - Docker Desktop Environment\n"
    echo

  else
    printf "dde - Docker Desktop Environment\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde COMMAND\n"
  printf "  dde [COMMAND] --help | -h\n"
  printf "  dde --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n" "init   "
  printf "  %s   Lists all available services\n" "list   "
  printf "  %s   Starts or restarts (if flag -r is given) one or several \n" "start  "
  printf "  %s   Shortcut for dde start -r\n" "restart"
  printf "  %s   Builds or rebuilds one or multiple containers. \n" "build  "
  printf "  %s   Starts bash in default cli container or alternative container if given\n" "bash   "
  printf "  %s   Executes a specific command on the default (or given via --service) service\n" "command"
  printf "  %s   Test command for development\n" "test   "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dde_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  else
    printf "dde init - Initializes dde. Only has to be run once from directory docker-dev-environment is installed\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde init\n"
  printf "  dde init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde list - Lists all available services\n"
    echo

  else
    printf "dde list - Lists all available services\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde list\n"
  printf "  dde list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dde_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde start\n"
    echo

    printf "  Starts or restarts (if flag -r is given) one or several \n   containers if provided. Use colon seperated list for multiple containers. \n   If no containers are given all the containers needed for \n   an application are started as defined in the local .env file. \n   See .env.project.sample for documentation\n"
    echo

  else
    printf "dde start - Starts or restarts (if flag -r is given) one or several \n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde start [CONTAINER] [OPTIONS]\n"
  printf "  dde start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--restart, -r"
    printf "    forces restart if container is running\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CONTAINER"
    printf "    Name of container(s)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  \"dde start\": starts all the containers defined in the variable\n  DOCKER_CONTAINER\n"
    printf "  \"dde start -r\": as above, but containers are stopped first if running\n"
    printf "  \"dde start -r apache-24,php-fpm-81\": restarts the two given containers\n"
    echo

  fi
}

# :command.usage
dde_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde restart - Shortcut for dde start -r\n"
    echo

  else
    printf "dde restart - Shortcut for dde start -r\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde restart [CONTAINER]\n"
  printf "  dde restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CONTAINER"
    printf "    Name of container(s), see dde start -h for more help\n"
    echo

  fi
}

# :command.usage
dde_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde build\n"
    echo

    printf "  Builds or rebuilds one or multiple containers. \n   If multiple container building is desired use colon seperated list.\n   If container list is omitted, all containers needed for your\n   application (as defined in your local .env file) will be built or \n   rebuilt.\n   If the --all option is given, all dde containers are built. \n   BEWARE: this might take some time. \n   If the --restart option is given, the service will be restarted after\n   being built. BEWARE: you can not combine the two options,\n   as there are too many containers to be run at\n   the same time.\n  \n   The command uses the --force-rm --no-cache --pull options from\n   ${DOCKER_COMPOSE_COMMAND} build and therefor takes some time. \n   For more fine grained tuning use\n  \n   ${DOCKER_COMPOSE_COMMAND} build -f\n  ${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml build\n  \n   with the options that suite you best.\n"
    echo

  else
    printf "dde build - Builds or rebuilds one or multiple containers. \n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde build [CONTAINER] [OPTIONS]\n"
  printf "  dde build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Build all containers defined in the dde docker-compose.yml\n"
    echo

    # :flag.usage
    printf "  %s\n" "--restart, -r"
    printf "    restarts (or starts) the (re)built container\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "CONTAINER"
    printf "    Name of container(s)\n"
    echo

  fi
}

# :command.usage
dde_bash_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  else
    printf "dde bash - Starts bash in default cli container or alternative container if given\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde bash [OPTIONS]\n"
  printf "  dde bash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    printf "  %s\n" "--root, -o"
    printf "    Starts command as root user\n"
    echo

    # :flag.usage
    printf "  %s\n" "--default-working-dir, -d"
    printf "    Uses default working dir of the container rather than the project root\n"
    echo

    # :flag.usage
    printf "  %s\n" "--working-dir, -w WORKING_DIR"
    printf "    The working dir to execute the bash in. If not specified the project root is\n    used.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--service, -s SERVICE"
    printf "    The service to execute the command in, defaults to the one \n     defined in \$DEFAULT_CONTAINER\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  dde bash: Starts ab bash on the running default service\n"
    printf "  dde bash -r -o -s mysql-80: Starts a bash in a newly created mysql-80 service\n  as root\n"
    echo

  fi
}

# :command.usage
dde_command_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde command - Executes a specific command on the default (or given via --service) service\n"
    echo

  else
    printf "dde command - Executes a specific command on the default (or given via --service) service\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde command COMMAND [OPTIONS]\n"
  printf "  dde command --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--run, -r"
    printf "    Uses docker run instead of docker exec\n"
    echo

    # :flag.usage
    printf "  %s\n" "--root, -o"
    printf "    Starts command as root user\n"
    echo

    # :flag.usage
    printf "  %s\n" "--default-working-dir, -d"
    printf "    Uses default working dir of the container rather than the project root\n"
    echo

    # :flag.usage
    printf "  %s\n" "--working-dir, -w WORKING_DIR"
    printf "    The working dir to execute the command in. If not specified the project root\n    is used.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--service, -s SERVICE"
    printf "    The service to execute the command in, defaults to the one \n     defined in \$DEFAULT_CONTAINER\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-tty, -T"
    printf "    Do not allocate tty while executing command. This is needed for execution of\n    cronjobs.\n     See the documentation for more details\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMAND"
    printf "    The command to execute, needs to be quoted if it contains spaces\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  dde command \"ls -l\": lists the dir content on the running default service\n"
    printf "  dde c -T -s redis-5 redis-cli flushall: flushes the redis cache from a cron\n  job (i.e. without tty)\n"
    echo

  fi
}

# :command.usage
dde_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "dde test - Test command for development\n"
    echo

  else
    printf "dde test - Test command for development\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dde test COMMAND [OPTIONS]\n"
  printf "  dde test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--service, -s SERVICE"
    printf "    The service to execute the\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "COMMAND"
    printf "    The command to execute\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/build.sh
touchConfigFile () {

  if [[ $1 =~ "php" ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/php/php.ini"
  fi

  if [[ $1 =~ mysql|percona|mariadb ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/my.cnf"
  fi

  if [[ $1 =~ "ssh" ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/tunnel.conf"
  fi

  if [[ $1 =~ "nginx" ]]; then
      configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/nginx/conf.d/default.conf"
  fi

  if [[ $1 =~ "varnish" ]]; then
    configFile="${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/varnish/default.vcl"
  fi

  if [[ -n "${configFile}" && ! -f "${configFile}" ]]; then
    if [[ $1 =~ "php" ]]; then
      echo 'Copying ini files, adopt to your needs'
      cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/sample/conf.d/"*.ini \
         "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/php/conf.d"
      cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/sample/php.ini.sample" \
         "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/php/php.ini"
    elif [[ $1 =~ "nginx" ]]; then
        echo 'Copying config file, adopt to your needs'
        cp -R "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/sample/conf.d/default.conf" \
            "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/nginx/conf.d"
    elif [[ $1 =~ "varnish" ]]; then
        echo 'Copying config file, adopt to your needs'
        cp "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/sample/default.vcl" \
            "${DOCKER_DEV_ENVIRONMENT_HOME}/config/$1/etc/varnish/"
    else
        echo "Touching ${configFile} before startup, because it does not exist"
        touch "${configFile}"
    fi
  fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/init.sh
init_rc() {

  cat >> "${BASHRC_FILE}" <<EOL_SH
#
# initialising docker dev environment
#
source ~/.docker/.dderc
EOL_SH
}

init_path() {
    cat > ~/.docker/.dderc <<EOL_PATH
#
# initialising docker dev environment
#
export DOCKER_DEV_ENVIRONMENT_HOME="${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}"
if [[ -d "\${DOCKER_DEV_ENVIRONMENT_HOME}/bin" ]]; then
    PATH="\${DOCKER_DEV_ENVIRONMENT_HOME}/bin:\${PATH}"
fi
if [[ -f "${DOCKER_DEV_ENVIRONMENT_HOME}/bin/completions.bash" ]]; then
    . "${DOCKER_DEV_ENVIRONMENT_HOME}/bin/completions.bash"
fi
EOL_PATH
}

# :command.command_functions
# :command.function
dde_init_command() {
  # src/init_command.sh
  REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME=$(readlink -f "${MY_PATH}/..")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  # if it is no set or changed
  #
  if [[ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then

      BASHRC_FILE="${HOME}/.bashrc"
      #
      # check if source command is included in .bashrc if the file exists
      #
      if [[ -f $BASHRC_FILE  && "$(grep -c ".docker/.dderc" "${BASHRC_FILE}")" = "0" ]]; then
          init_rc
      fi

      ZSHRC_FILE="${HOME}/.zshrc"
      #
      # check if source command is included in .zshrc if the file exists
      #
      if [[ -f $ZSHRC_FILE  && "$(grep -c ".docker/.dderc" "${ZSHRC_FILE}")" = "0" ]]; then
          init_rc
      fi

      #
      # check if .devenvrc file exists
      #
      if [[ ! -d ~/.docker ]]; then
         mkdir ~/.docker
      fi

      if [[ ( ! -f ~/.docker/.dderc ) || "${REQUESTED_DOCKER_DEV_ENVIRONMENT_HOME}" != "${DOCKER_DEV_ENVIRONMENT_HOME}" ]]; then
          init_path
      fi

      green "docker dev environment initialized or changed, please type"
      if [[ "$(grep -c "/bash" "${SHELL}")" != "0" ]]; then
          green "$ source $BASHRC_FILE "
      elif [[ "$(grep -c "/zsh" "${SHELL}")" != "0" ]]; then
          green "$ source $ZSHRC_FILE "
      else
          green "$ source /pfad/zur/config/datei/der/shell "
      fi
      green "to see effects"
  else
      magenta "docker dev environment already initialised"
  fi

}

# :command.function
dde_list_command() {
  # src/list_command.sh
  green "Listing all defined services:"
  ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" config --services

}

# :command.function
dde_start_command() {
  # src/start_command.sh
  parse_command_args
  if [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
         while IFS=',' read -ra CONTAINER; do
            for container in "${CONTAINER[@]}"; do
                if [ -v "args[--restart]" ]; then
                   ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" stop ${container}
                fi
                touchConfigFile "${container}"
               ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" up -d ${container}
            done
         done <<< "${CONTAINER_LIST}"
  fi

}

# :command.function
dde_restart_command() {
  # src/restart_command.sh
  parse_command_args
  if [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
      dde start "${CONTAINER_LIST}" -r
  fi

}

# :command.function
dde_build_command() {
  # src/build_command.sh
  parse_command_args
  if [ -v "args[--all]" ]; then
      if [ -v "args[--restart]" ]; then
          red "You can not provide the two options together!"
      else
         ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" build "${BUILD_OPTIONS}"
      fi
  elif [ -v CONTAINER_WARNING ]; then
      red "${CONTAINER_WARNING}"
      red "${ENV_WARNING}"
  else
         while IFS=',' read -ra CONTAINER; do
            for container in "${CONTAINER[@]}"; do
               ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" build \
                   --force-rm --pull --no-cache "${container}"
                if [ -v "args[--restart]" ]; then
                    dde restart "${container}"
                fi
            done
         done <<< "${CONTAINER_LIST}"
  fi

}

# :command.function
dde_bash_command() {
  # src/bash_command.sh
  #inspect_args
  parse_command_args
  if [ -v SERVICE_WARNING ]; then
      red "${SERVICE_WARNING}"
      red "${ENV_WARNING}"
  else
     ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" "${MODEPART[@]}" \
          "${USERPART[@]}" "${WORKINGDIRPART[@]}" "${SERVICE}" bash
  fi

}

# :command.function
dde_command_command() {
  # src/command_command.sh
  parse_command_args
  if [ -v SERVICE_WARNING ]; then
      red "${SERVICE_WARNING}"
      red "${ENV_WARNING}"
  else
     ${DOCKER_COMPOSE_COMMAND} -f "${DOCKER_DEV_ENVIRONMENT_HOME}/docker-compose.yml" "${MODEPART[@]}" \
          "${TTYPART[@]}" "${USERPART[@]}" "${WORKINGDIRPART[@]}" "${SERVICE}" "${COMMAND[@]}"
  fi

}

# :command.function
dde_test_command() {
  # src/test_command.sh
  inspect_args
  if [ -v "args[--service]" ]; then
      red "${args[--service]}"
  fi
  green "done"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dde_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      dde_init_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      dde_list_parse_requirements "$@"
      shift $#
      ;;

    start)
      action="start"
      shift
      dde_start_parse_requirements "$@"
      shift $#
      ;;

    restart)
      action="restart"
      shift
      dde_restart_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      dde_build_parse_requirements "$@"
      shift $#
      ;;

    bash)
      action="bash"
      shift
      dde_bash_parse_requirements "$@"
      shift $#
      ;;

    command)
      action="command"
      shift
      dde_command_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      dde_test_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dde_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dde_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dde_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dde_start_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_start_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --restart | -r)

        # :flag.case_no_arg
        args['--restart']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['container']+x} ]]; then

          args['container']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
dde_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['container']+x} ]]; then

          args['container']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
dde_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --all | -a)

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      # :flag.case
      --restart | -r)

        # :flag.case_no_arg
        args['--restart']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['container']+x} ]]; then

          args['container']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
dde_bash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_bash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --run | -r)

        # :flag.case_no_arg
        args['--run']=1
        shift
        ;;

      # :flag.case
      --root | -o)

        # :flag.case_no_arg
        args['--root']=1
        shift
        ;;

      # :flag.case
      --default-working-dir | -d)

        # :flag.case_no_arg
        args['--default-working-dir']=1
        shift
        ;;

      # :flag.case
      --working-dir | -w)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--working-dir']="$2"
          shift
          shift
        else
          printf "%s\n" "--working-dir requires an argument: --working-dir, -w WORKING_DIR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --service | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--service']="$2"
          shift
          shift
        else
          printf "%s\n" "--service requires an argument: --service, -s SERVICE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dde_command_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_command_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="command"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --run | -r)

        # :flag.case_no_arg
        args['--run']=1
        shift
        ;;

      # :flag.case
      --root | -o)

        # :flag.case_no_arg
        args['--root']=1
        shift
        ;;

      # :flag.case
      --default-working-dir | -d)

        # :flag.case_no_arg
        args['--default-working-dir']=1
        shift
        ;;

      # :flag.case
      --working-dir | -w)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--working-dir']="$2"
          shift
          shift
        else
          printf "%s\n" "--working-dir requires an argument: --working-dir, -w WORKING_DIR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --service | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--service']="$2"
          shift
          shift
        else
          printf "%s\n" "--service requires an argument: --service, -s SERVICE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-tty | -T)

        # :flag.case_no_arg
        args['--no-tty']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['command']+x} ]]; then
    printf "missing required argument: COMMAND\nusage: dde command COMMAND [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
dde_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dde_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --service | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--service']="$2"
          shift
          shift
        else
          printf "%s\n" "--service requires an argument: --service, -s SERVICE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['command']+x} ]]; then
    printf "missing required argument: COMMAND\nusage: dde test COMMAND [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh
  # use extended globbing
  shopt -s extglob

  # where is this file located
  SCRIPT_PATH=$(readlink -f "$0")
  MY_PATH=$(dirname "$SCRIPT_PATH")

  #
  # sets DOCKER_DEV_ENVIRONMENT_HOME
  #
  if [ -z "${DOCKER_DEV_ENVIRONMENT_HOME+x}" ]; then
      magenta "Warning: dde not initialised, use dde init to do so"
  fi

  # initializes the dde wide variables like user id etc.
  # see .env.sample
  #
  if [ -f "${MY_PATH}/../.env" ]; then
   set -a
   . "${MY_PATH}/../.env"
   set +a
  else
    echo "Please copy the file .env.sample file inside your docker-dev-environment to .env and change according to your needs"
    exit 1
  fi

  # initializes the specific container needs for a given project
  # see .env.dde.sample
  if [ -f "${PWD}/.env.dde" ]; then
    set -a
    . "${PWD}/.env.dde"
    set +a
  elif [ -f "${PWD}/.env" ]; then
    set -a
    . "${PWD}/.env"
    set +a
  elif [ "${DOCKER_DEV_ENVIRONMENT_HOME}" != "${PWD}" ]; then
    ENV_WARNING="Warning: there is no .env in your current working dir. Wrong pwd or missing project initialisation?"
  fi

  # parses the command args
  # see https://github.com/koalaman/shellcheck/wiki/SC2086 for argument parsing in shell
  function parse_command_args() {

      # determine working dir
      if [ -v "args[--default-working-dir]" ]; then
          WORKINGDIRPART=()
      elif [ -v "args[--working-dir]" ]; then
          WORKINGDIRPART=(-w "${args[--working-dir]}")
      elif [ -v "PROJECT_ROOT" ]; then
          WORKINGDIRPART=(-w /var/www/vhosts/${PROJECT_ROOT})
      else
          VHOSTS_BASE=$(realpath "${DOCKER_DEV_ENVIRONMENT_HOME}"/vhosts)
          REL_PATH=${PWD#@($VHOSTS_BASE/)}
          WORKINGDIRPART=(-w "/var/www/vhosts/${REL_PATH}")
      fi

      # set root user if desired
      if [ -v "args[--root]" ]; then
          USERPART=(-u root)
      else
          USERPART=(-u ${USER_ID})
      fi

      # determine run type

      if [ -v "args[--run]" ]; then
          MODEPART=(run --rm)
      else
          MODEPART=(exec)
      fi

      #
      if [ -v "args[--no-tty]" ]; then
          TTYPART=(-T)
      else
          TTYPART=()
      fi

      # seek default service for command execution
      if [ -v "args[--service]" ]; then
          SERVICE="${args[--service]}"
      # inspect PHP_CLI_CONTAINER for backward compatibility
      elif [ -v "PHP_CLI_CONTAINER" ]; then
          SERVICE="${PHP_CLI_CONTAINER}"
      elif [ -v "DEFAULT_CONTAINER" ]; then
          SERVICE="${DEFAULT_CONTAINER}"
      else
          SERVICE_WARNING="Could not determine the service to execute the command on!"
      fi

      # prepares the container list for dde start and dde build
      if [ -v "args[container]" ]; then
          CONTAINER_LIST="${args[container]}"
      elif [ -v "DOCKER_CONTAINER" ]; then
          CONTAINER_LIST="${DOCKER_CONTAINER}"
          # inspect PHP_FPM_CONTAINER for backward compatibility
          if [ -v "PHP_FPM_CONTAINER" ]; then
              CONTAINER_LIST="${CONTAINER_LIST},${PHP_FPM_CONTAINER}"
          fi
      else
          CONTAINER_WARNING="No container given!"
      fi

      if [ -v "args[command]" ]; then
          IFS=" " read -ra COMMAND<<<"${args[command]}"
      fi
  }

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") dde_init_command ;;
    "list") dde_list_command ;;
    "start") dde_start_command ;;
    "restart") dde_restart_command ;;
    "build") dde_build_command ;;
    "bash") dde_bash_command ;;
    "command") dde_command_command ;;
    "test") dde_test_command ;;
  esac
}

initialize
run "$@"
